# 设计模式
该章节主要是在读《Head First 设计模式》的总结。

## 组合模式
核心：多用组合，少用继承。

案例：鸭子应用（模拟鸭子游戏）。
游戏中需要设计各种鸭子，有戏水的、呱呱叫的。用学习过的OO技术，张三（鸭子游戏“首席架构师”）首先会设计一个鸭子超类，并让各种鸭子继承该超类。
![OO类图1]()

类图中，超类Duck实现了鸭子呱呱叫（quack）和游泳（swim），由于鸭子外观都不同，所以display()方法是抽象的，由子类去实现。
具体代码在该项目的位置：JavaInterview/architecture/src/main/java/cn.tommyyang.designpatterns.duckgame.Duck。

以上完成第一版鸭子应用。

由于鸭子游戏鸭子种类一直就那么几种，导致游戏用户增长上遇到了较大的频颈，所以急需创新。通过大家的头脑风暴，首先我们得让鸭子飞起来。这时，负责鸭子应用的开发人员张三接到了这个需求，认为只需在Duck超类上加上fly方法即可。设计如下：
![OO类图2]()

改完后，完成了游戏的第二次发版。改动点：
- 加入鸭子会飞的逻辑。
- 有鸭子的叫声不是呱呱叫，而是吱吱叫。

发布完成后，在公司内部开始进行试运行。试运行期间，同事们说，为什么橡皮鸭也会飞啊。张三收到了反馈后，他发现出问题了，不能直接在超类进行fly()方法的实现，或者在橡皮鸭内部覆盖fly方法，然后什么都不做。
如果后面有几万种鸭子，比如加入了诱饵鸭（是木头鸭），不会飞也不会叫，那怎么办，也去覆盖quack、fly方法？那这样继承这些方法有什么意义呢？
看到这里，不知道大家怎么想？

首先总结下利用继承来提供Duck的行为会导致哪些缺点：
- 代码在多个子类中重复。
- 运行时的行为不容易改变。
- 不能让鸭子跳舞。
- 很难知道所有鸭子的全部行为。
- 鸭子不能同时又飞又叫。
- 改变会牵一发动全身，造成其他鸭子不想要的改变。


## 策略模式

## 观察者模式

## 装饰模式

## 工厂模式
### 简单工厂模式

### 工厂方法模式